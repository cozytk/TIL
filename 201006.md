# 201006 ğŸ…ğŸ…ğŸ…ğŸ…ğŸ…ğŸ…ğŸ…ğŸ…


# Exam 02

---

# INTER

### ì²«ë²ˆì§¸ ì¸ì

ì•ì—ì„œ ë¶€í„° ì½ê³  ê³‚ì¹˜ëŠ” ê²ƒë“¤ì€ ë°”ê¿”ì„œ ì¬ìƒì‚°

â†’ ì†Œë¬¸ì ê°’ë§Œí¼ì˜ ascii codeë¥¼ ê°€ì§„ ë°°ì—´ì„ ì„ ì–¸í•œ í›„ ì ìš©ã…‡

### ë‘ë²ˆì§¸ ì¸ì

ì•ì—ì„œ ë¶€í„° ì½ìœ¼ë©´ì„œ í•´ë‹¹í•˜ë©´ ë°”ë¡œ ì¶œë ¥

### êµ¬ìƒ

```c
char alphabet[26];
char str[strlen(argv[1])];
int j = 0;
// if it failed try malloc

if (argc == 3)
{
	for (int i = 0; i < strlen(argv[1]); i++)
	{if (alphabet exist)
		continue ;
	str[j++] = argv[1][i];
	alphabet[argv[1][i] - 97] = 1;}
	str[j] = '\0';
	j = 0;
}
printf("\n");
return (0);
```

### ìµœì¢… ì½”ë“œ

```c
#include <unistd.h>

int	ft_strlen(char *s)
{
	int i = 0;

	while (s[i])
		i++;
	return (i);
}

int	ft_strchr(char *s, char c)
{
	int i = 0;

	while (s[i])
	{
		if (s[i] == c)
			return (1);
		i++;
	}
	return (0);
}

int	main(int argc, char **argv)
{
	int alphabet[128] = { 0, };
	char str[100];
	int j = 0;

	if (argc == 3)
	{
		for (int i = 0; argv[1][i]; i++)
		{
			if (alphabet[(int)argv[1][i]])
				continue ;
			str[j++] = argv[1][i];
			alphabet[(int)argv[1][i]] = 1;
		}
		str[j] = '\0';
		for (int i = 0; str[i]; i++)
		{
			if (ft_strchr(argv[2], str[i]))
				write(1, &str[i], 1);
		}
	}
	write(1, "\n", 1);
	return (0);
}
```

í›„ê¸°

1. 100ë§Œí¼ì˜ ê³ ì • ë°°ì—´ strì„ ì„ ì–¸í•œ ê²ƒì´ ì•„ì‰¬ì›€
2. ì •ì  ë°°ì—´ì— ëª¨ë“  ê°’ì— 0ì„ ì´ˆê¸°í™” í•˜ë©´ì„œ ì„ ì–¸í•˜ëŠ” ë²•ì„ ìƒê¸°ì‹œí‚´

```c
int alphabet[128] = { 0, };
```

# libasm

label : operator | operand1 | operand2 | ; | comments|

### Operators

- mov : allocate operand2 to operand1
- add : operand1 += operand2
- sub : operand1 -= operand2
- inc : operand1++
- dec : operand1â€”
- jmp : conditional
- push : save to stack, empty register
- pop : take stack
- cmp : operand - operand2 (0 if it's same)
- call : call procedure
- ret : move next to call
